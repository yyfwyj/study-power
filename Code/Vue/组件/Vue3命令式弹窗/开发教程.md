# Vue3 命令式弹窗开发教程

## 什么是命令式API？

**命令式API（Imperative API）**：通过函数调用直接操作DOM或组件，例如 `alert()`、`confirm()` 等浏览器原生API。

**声明式API（Declarative API）**：通过模板和数据绑定来控制UI，例如 `v-if`、`v-show` 等Vue指令。

命令式弹窗的优势：
- 无需在模板中预先定义组件
- 可以在任何地方通过函数调用打开弹窗
- 代码更简洁，使用更方便
- 支持动态创建和销毁

---

## 开发阶段与步骤

### 阶段一：创建弹窗组件基础结构

#### 步骤1：创建弹窗组件模板结构

**要做什么：**
在 `Model.vue` 中创建弹窗的基础HTML结构，包括遮罩层、弹窗容器、标题、内容和操作按钮。

**示例代码：**
```vue
<template>
  <Teleport to="body">
    <Transition name="modal">
      <div v-if="visible" class="modal-overlay" @click.self="handleClose">
        <div class="modal-container">
          <div class="modal-header">
            <h2 class="modal-title">{{ title }}</h2>
            <button class="modal-close" @click="handleClose">×</button>
          </div>
          <div class="modal-body">
            <slot></slot>
          </div>
          <div class="modal-footer" v-if="showFooter">
            <button class="btn btn-cancel" @click="handleCancel">取消</button>
            <button class="btn btn-confirm" @click="handleConfirm">确认</button>
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>
```

**用意说明：**
- `Teleport`：将弹窗渲染到body下，避免z-index和定位问题
- `Transition`：提供进入/离开动画效果
- `v-if="visible"`：控制弹窗显示/隐藏
- `@click.self`：点击遮罩层时关闭弹窗
- `slot`：允许传入自定义内容

---

#### 步骤2：添加组件逻辑和Props定义

**要做什么：**
定义组件的props、emits和内部状态，处理弹窗的显示/隐藏逻辑。

**示例代码：**
```vue
<script setup>
import { ref, watch } from 'vue'

const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: '提示'
  },
  showFooter: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  }
})

const emit = defineEmits(['update:visible', 'close', 'confirm', 'cancel'])

const handleClose = () => {
  if (props.closeOnClickOverlay) {
    emit('update:visible', false)
    emit('close')
  }
}

const handleConfirm = () => {
  emit('confirm')
  emit('update:visible', false)
  emit('close')
}

const handleCancel = () => {
  emit('cancel')
  emit('update:visible', false)
  emit('close')
}

// 监听ESC键
const handleKeydown = (e) => {
  if (e.key === 'Escape' && props.visible && props.closeOnPressEscape) {
    handleClose()
  }
}

watch(() => props.visible, (newVal) => {
  if (newVal) {
    document.addEventListener('keydown', handleKeydown)
    // 禁止背景滚动
    document.body.style.overflow = 'hidden'
  } else {
    document.removeEventListener('keydown', handleKeydown)
    document.body.style.overflow = ''
  }
})
</script>
```

**用意说明：**
- `defineProps`：定义组件接收的属性，支持自定义配置
- `defineEmits`：定义组件可以触发的事件
- `watch`：监听visible变化，控制键盘事件和body滚动
- `handleKeydown`：支持ESC键关闭弹窗
- `document.body.style.overflow`：弹窗打开时禁止背景滚动

---

#### 步骤3：添加样式和动画效果

**要做什么：**
编写CSS样式，包括遮罩层、弹窗容器、动画效果等。

**示例代码：**
```vue
<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(4px);
}

.modal-container {
  background: white;
  border-radius: 12px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid #eee;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-title {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.modal-close {
  background: none;
  border: none;
  font-size: 28px;
  color: #999;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s;
}

.modal-close:hover {
  background: #f5f5f5;
  color: #333;
}

.modal-body {
  padding: 24px;
  overflow-y: auto;
  flex: 1;
}

.modal-footer {
  padding: 16px 24px;
  border-top: 1px solid #eee;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
}

.btn {
  padding: 8px 20px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.btn-cancel {
  background: #f5f5f5;
  color: #333;
}

.btn-cancel:hover {
  background: #e8e8e8;
}

.btn-confirm {
  background: #667eea;
  color: white;
}

.btn-confirm:hover {
  background: #5568d3;
}

/* 动画效果 */
.modal-enter-active,
.modal-leave-active {
  transition: opacity 0.3s ease;
}

.modal-enter-active .modal-container,
.modal-leave-active .modal-container {
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.modal-enter-from,
.modal-leave-to {
  opacity: 0;
}

.modal-enter-from .modal-container,
.modal-leave-to .modal-container {
  transform: scale(0.9) translateY(-20px);
  opacity: 0;
}
</style>
```

**用意说明：**
- `position: fixed`：固定定位，覆盖整个视口
- `backdrop-filter: blur(4px)`：背景模糊效果
- `z-index: 1000`：确保弹窗在最上层
- `flex`布局：实现居中显示
- `Transition`配合CSS：实现淡入淡出和缩放动画
- `overflow-y: auto`：内容过多时可滚动

---

### 阶段二：创建命令式API

#### 步骤4：创建弹窗实例管理工具

**要做什么：**
创建一个工具函数，用于动态创建和挂载Vue组件实例，实现命令式调用。

**示例代码：**
```javascript
// 创建 useModal.js 文件
import { createApp, h } from 'vue'
import Modal from './Model.vue'

// 创建弹窗实例的函数
export function createModal(options = {}) {
  // 创建容器元素
  const container = document.createElement('div')
  document.body.appendChild(container)

  // 创建Vue应用实例
  const app = createApp({
    setup() {
      const visible = ref(true)
      
      const close = () => {
        visible.value = false
        // 延迟销毁，等待动画完成
        setTimeout(() => {
          app.unmount()
          document.body.removeChild(container)
        }, 300)
      }

      const confirm = () => {
        if (options.onConfirm) {
          options.onConfirm()
        }
        close()
      }

      const cancel = () => {
        if (options.onCancel) {
          options.onCancel()
        }
        close()
      }

      return () => h(Modal, {
        visible: visible.value,
        title: options.title || '提示',
        showFooter: options.showFooter !== false,
        'onUpdate:visible': (val) => {
          visible.value = val
          if (!val) close()
        },
        onClose: close,
        onConfirm: confirm,
        onCancel: cancel
      }, {
        default: () => options.content || options.render?.()
      })
    }
  })

  app.mount(container)
  
  return {
    close: () => {
      const visible = app._instance?.setupState?.visible
      if (visible) {
        visible.value = false
      }
    }
  }
}
```

**用意说明：**
- `createApp`：创建独立的Vue应用实例
- `h`函数：创建虚拟DOM节点（渲染函数）
- `document.createElement`：动态创建DOM容器
- `app.mount`：将应用挂载到容器
- `app.unmount`：卸载应用，清理资源
- 返回close方法：允许外部关闭弹窗

---

#### 步骤5：创建便捷的API函数

**要做什么：**
创建多个便捷函数，如 `showModal`、`showConfirm`、`showAlert` 等，简化使用。

**示例代码：**
```javascript
// 在 useModal.js 中添加

// 基础弹窗
export function showModal(options) {
  return createModal(options)
}

// 确认对话框
export function showConfirm(options) {
  return createModal({
    title: options.title || '确认',
    content: options.content || options.message || '确定要执行此操作吗？',
    showFooter: true,
    onConfirm: options.onConfirm,
    onCancel: options.onCancel
  })
}

// 警告提示
export function showAlert(options) {
  return createModal({
    title: options.title || '提示',
    content: options.content || options.message || '操作成功',
    showFooter: false,
    closeOnClickOverlay: true
  })
}

// 输入对话框（扩展功能）
export function showPrompt(options) {
  // 可以扩展为带输入框的弹窗
  // 这里先返回基础实现
  return createModal({
    title: options.title || '输入',
    content: options.content || '',
    showFooter: true,
    onConfirm: () => {
      // 获取输入值并回调
      if (options.onConfirm) {
        options.onConfirm(/* 输入值 */)
      }
    }
  })
}
```

**用意说明：**
- `showModal`：通用弹窗函数
- `showConfirm`：确认对话框，常用场景
- `showAlert`：提示信息，无需操作按钮
- `showPrompt`：输入对话框，可扩展功能
- 统一API：简化调用方式，提高开发效率

---

### 阶段三：集成和使用

#### 步骤6：在HomePage中使用命令式API

**要做什么：**
更新 `HomePage.vue`，导入并使用命令式API函数。

**示例代码：**
```vue
<script setup>
import { showModal, showConfirm, showAlert } from './useModal.js'

const openModal = () => {
  showModal({
    title: '欢迎使用命令式弹窗',
    content: '这是一个通过函数调用打开的弹窗，无需在模板中定义组件！',
    showFooter: true,
    onConfirm: () => {
      console.log('用户点击了确认')
      showAlert({
        title: '成功',
        message: '操作已确认！'
      })
    },
    onCancel: () => {
      console.log('用户点击了取消')
    }
  })
}

const openConfirm = () => {
  showConfirm({
    title: '删除确认',
    message: '确定要删除这条记录吗？此操作不可恢复。',
    onConfirm: () => {
      showAlert({
        title: '已删除',
        message: '记录已成功删除'
      })
    }
  })
}

const openAlert = () => {
  showAlert({
    title: '提示',
    message: '这是一个简单的提示信息'
  })
}
</script>
```

**用意说明：**
- 导入API函数：从工具文件导入
- 函数调用：直接调用函数即可打开弹窗
- 无需模板：不需要在template中写 `<Modal>` 组件
- 回调处理：通过onConfirm/onCancel处理用户操作
- 链式调用：可以在回调中打开新的弹窗

---

#### 步骤7：更新模板添加多个测试按钮

**要做什么：**
在模板中添加多个按钮，测试不同的弹窗类型。

**示例代码：**
```vue
<template>
  <div class="home-page">
    <div class="hero-section">
      <h1 class="title">Vue3 命令式弹窗示例</h1>
      <p class="subtitle">体验现代化的弹窗交互效果</p>
      <div class="button-group">
        <button class="open-modal-btn" @click="openModal">
          打开基础弹窗
        </button>
        <button class="open-modal-btn" @click="openConfirm">
          打开确认对话框
        </button>
        <button class="open-modal-btn" @click="openAlert">
          打开提示信息
        </button>
      </div>
    </div>
    <!-- ... 其他内容 ... -->
  </div>
</template>
```

**用意说明：**
- 多个按钮：测试不同类型的弹窗
- 统一样式：使用相同的按钮样式
- 交互测试：验证各种使用场景

---

## 完整的技术原理说明

### 核心原理

1. **动态组件创建**：使用 `createApp` 创建独立的Vue应用实例
2. **渲染函数**：使用 `h` 函数（createElement）动态创建组件
3. **DOM操作**：动态创建容器元素并挂载应用
4. **生命周期管理**：手动控制组件的创建和销毁

### 优势对比

| 特性 | 声明式方式 | 命令式方式 |
|------|-----------|-----------|
| 模板代码 | 需要在template中写组件 | 无需模板代码 |
| 调用方式 | 通过v-if控制 | 直接函数调用 |
| 代码简洁性 | 需要维护状态 | 一行代码调用 |
| 灵活性 | 受限于模板结构 | 可在任何地方调用 |
| 适用场景 | 固定位置的弹窗 | 动态、临时的弹窗 |

### 注意事项

1. **内存管理**：确保弹窗关闭时正确卸载应用实例
2. **事件清理**：移除事件监听器，避免内存泄漏
3. **动画处理**：等待动画完成后再销毁DOM
4. **多实例**：支持同时打开多个弹窗实例
5. **样式隔离**：使用scoped避免样式冲突

---

## 扩展功能建议

1. **支持Promise**：返回Promise，支持async/await语法
2. **动画配置**：支持自定义动画效果
3. **尺寸配置**：支持不同尺寸的弹窗（small、medium、large）
4. **位置配置**：支持不同位置的弹窗（top、center、bottom）
5. **主题配置**：支持深色/浅色主题
6. **国际化**：支持多语言
7. **表单弹窗**：支持表单输入和验证

---

## 总结

通过以上步骤，我们实现了一个完整的命令式弹窗系统：

1. ✅ 创建了可复用的弹窗组件
2. ✅ 实现了命令式API调用方式
3. ✅ 提供了多种便捷函数
4. ✅ 集成了动画和交互效果
5. ✅ 支持灵活配置和扩展

这种实现方式让弹窗的使用更加灵活和便捷，特别适合在工具函数、API调用、错误处理等场景中使用。


