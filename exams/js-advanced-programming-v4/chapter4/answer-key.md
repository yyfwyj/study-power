# 答案与要点（第4章试卷）

## 选择题
1）C  2）D  3）C  4）C  5）B  6）B  7）B  8）B  9）B  10）C

## 填空题
1）Undefined；Null；Boolean；Number；String；Symbol
2）栈；堆
3）指针/引用
4）arguments
5）SyntaxError
6）"object"
7）错误对象（捕获的异常对象）
8）循环引用
9）构造函数（或对象创建时）
10）null

## 判断题
1）错（原始类型，按值访问）
2）对
3）对
4）错（有提升但处于 TDZ，声明前访问抛错）
5）错（找到即停止）
6）对
7）错（delete 破坏隐藏类；设为 null 更安全）
8）对
9）对
10）错（`var` 仍提升到函数/全局作用域）

## 解答题（示例要点）
1）原始值直接存放值，赋值/传参复制值；引用值变量存放指针，赋值/传参复制指针，两个引用指向同一对象。
2）执行上下文决定可访问的变量对象；作用域链由当前活动对象到父上下文再到全局对象，按链搜索标识符。
3）`var` 函数/全局作用域，声明提升；`let/const` 块级作用域，存在 TDZ，`const` 需初始化且不可再赋值。
4）标记-清除：标记可达，清理不可达；引用计数：计数增减，计数为0回收，易被循环引用卡住。
5）TDZ 是从块头到声明语句前的区域，访问会抛 ReferenceError，防止在声明前使用。

## 论述题（要点提示）
1）调用栈入栈形成新上下文，作用域链前端是当前 AO；局部变量查找无需跨上下文，因而快于全局查找。
2）原始值小且不可变，复制值；引用值指针指向堆对象，复制指针会共享对象并受可达性影响。
3）V8 为相同属性布局共享隐藏类；动态增删属性会生成新隐藏类、失去优化，构造时一次性定义属性可避免。
4）浏览器内存受限，全局引用存活久；及时置 null、拆解监听/定时器、避免意外全局、控制缓存大小。
5）块级作用域结束即出作用域，可更早标记可回收；函数作用域要等函数返回；`let/const` 可缩短生命周期。

## 高频面试题（要点提示）
1）历史原因标记位导致；用 `value !== null && typeof value === 'object'` 或 `Object.prototype.toString` 判别。
2）全部按值传递；对象参数复制的是指针，重指向新对象不影响外部引用，可通过示例证明。
3）举 `console.log(x); let x = 1;` 抛 ReferenceError。
4）可达性以作用域链/引用图判断，无法从根（全局/闭包链）到达的对象被标记回收。
5）少用全局、清理定时器/监听、在不用时置 null、避免意外全局、减少动态增删属性、大对象短期缓存要过期。

## 高频场景题（要点提示）
1）长寿命计时器持有大对象导致不可回收；解决：清理计时器或在回调末尾置 null/弱引用。
2）`catch` 块结束后若无其他引用即可回收；因错误对象仅在块级作用域可达。
3）用 `for (let i = 0; i < n; i++) setTimeout(() => console.log(i));` 每次迭代绑定独立块级变量。
4）用 `typeof`/`Object.prototype.toString` 判原始 vs 对象，必要时深拷贝对象、防御式复制。
5）使用对象池、复用数组/对象、延迟创建、批量操作、减少中间对象。

## 场景编程题（示例方向）
1）`return value !== null && (typeof value === 'object' || typeof value === 'function');`
2）在函数中逐级查找，若未定义返回 `'unknown'`；可使用 `typeof` 检查避免 ReferenceError。
3）展示 `with(location){ console.log(href); }`，说明污染作用域链、降低可读性、易被禁用。
4）循环 `keys` 将 `obj[key] = null;`，不使用 `delete`，保持隐藏类稳定。
5）伪代码：两个对象互相引用，引用计数不归零而泄漏；在标记-清除中因不可达被回收。

## 项目开发题（要点方向）
1）清单包含：全局/单例控制、事件/定时器注册-注销规范、缓存过期策略、DOM 引用释放、弱引用使用、监控与分析流程。
2）接口示例：`allocate` 复用空闲对象，`free` 复位并入池；示例在矢量运算中复用结果对象减少分配。
3）代码展示嵌套作用域、变量遮蔽、`with`/`catch` 插入作用域、可达性示意图，并解释 GC 根到对象的路径。
