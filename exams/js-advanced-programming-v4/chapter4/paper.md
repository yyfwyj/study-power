# 《JavaScript高级程序设计》第四版 — 第4章试卷（变量、作用域与内存）
- 日期：2025-12-16
- 范围：第4章 变量、作用域与内存
- 题型与数量：选择题10；填空题10；判断题10；解答题5；论述题5；高频面试题5；高频场景题5；场景编程题5；项目开发题3
- 说明：所有题目均基于第4章内容，涉及原始值与引用值、执行上下文与作用域、变量声明、垃圾回收与内存管理等。

## 一、选择题（10题）
1）原始值与引用值的根本区别在于（ C ）。
A. 是否可变  B. 是否存放在栈内存  C. 访问方式是按值还是按引用  D. 是否可以序列化

2）关于原始值的动态属性，以下说法正确的是（ D ）。
A. 可以添加并持久存在  B. 添加后立即触发垃圾回收  C. 添加时会抛错  D. 赋值后不会报错但属性不会被保存

3）下列哪项描述了函数参数在 ECMAScript 中的传递方式（ C ）。
A. 原始值按值、引用值按引用  B. 全部按引用  C. 全部按值  D. 按调用者决定

4）使用 `typeof` 无法区分的类型组合是（ C ）。
A. string 与 number  B. boolean 与 undefined  C. object 与 null  D. function 与 object

5）作用域链的前端（最先被查找的对象）是（ B ）。
A. 全局变量对象  B. 当前执行上下文的变量对象/活动对象  C. 上层函数的变量对象  D. 原型对象

6）`with` 或 `try...catch` 的 `catch` 语句块会对作用域链造成的影响是（ B ）。
A. 无任何影响  B. 临时在作用域链前端新增一个变量对象  C. 删除全局对象  D. 把作用域链倒序

7）以下哪项关于 `var` 与 `let` 的提升行为是正确的（ B ）。
A. `var` 与 `let` 都不会提升  B. `var` 会提升声明，`let` 存在暂时性死区  C. `let` 会提升声明，`var` 不会  D. 二者都会连同赋值一起提升

8）下列哪项最可能导致 V8 隐藏类分裂、影响性能（ B ）。
A. 在构造函数中一次性声明所有属性  B. 对象创建后追加属性  C. 使用 `const` 声明对象  D. 使用对象字面量

9）标记-清除（mark-and-sweep）算法回收对象的关键依据是（ B ）。
A. 引用计数归零  B. 在可达的作用域链中被访问  C. 分配时间长短  D. 对象大小

10）以下哪个做法更有利于减少内存泄漏（ C ）。
A. 频繁使用全局变量  B. 长期运行的定时器中引用大对象  C. 在不再需要时手动将引用置为 `null`  D. 通过 `delete` 删除对象属性

## 二、填空题（10题）
1）ECMAScript 的6种原始类型是：__number______、___string_____、____null____、____undefined____、_____boolean___、______symbol__。
2）原始值通常存储在______栈__内存，引用值的对象实例存储在___堆_____内存。
3）复制原始值会得到一个新的副本；复制引用值会复制___指针_____，因此两个变量指向同一对象。
4）函数的活动对象初始时默认包含的特殊属性是___arguments_____。
5）在同一作用域内，`let` / `const` 重复声明会导致________（错误类型）。
6）`typeof null` 的结果是____function____。
7）在 `try...catch` 中，`catch` 块会在作用域链前端加入包含________的变量对象。
8）引用计数算法主要缺陷之一是遇到___变量相互引用_____时无法回收。
9）避免 V8 隐藏类分裂的建议做法是：在________中一次性声明所有属性。
10）解除引用的常见方式是将变量赋值为_____null___，以便垃圾回收标记为可回收。

## 三、判断题（10题，写“对”或“错”）
1）字符串在 ECMAScript 中是按引用存储的。（错 ）
2）`instanceof` 可用于区分不同的引用类型。（ 对）
3）全局上下文的变量在浏览器中会成为 `window` 对象的属性（`let/const` 顶级声明除外）。 （ 对）
4）块级作用域内用 `let` 声明的变量会提升且可在声明前使用。 （错）
5）在作用域链查找时，找到同名局部变量后仍会继续查找上层作用域。 （错 ）
6）标记-清除算法通过可达性来决定对象是否回收。 （错）
7）通过 `delete` 删除属性比将属性设为 `null` 更能保持隐藏类稳定。 （对 ）
8）长生命周期的全局定时器闭包引用大对象可能导致内存泄漏。 （ 对）
9）在严格模式下，给未声明的变量赋值会抛出错误。 （ 对）
10）在 `with` 语句内使用 `var` 声明的变量只存在于 `with` 块作用域内。 （ 对）

## 四、解答题（5题，解释概念）
1）解释“原始值按值访问、引用值按引用访问”的含义，并举例。
原始值按值访问：
我们在给一个变量赋值原始值后，这个变量我们就称为原始值变量，但是我们只能操作这个值，不能去动态添加，删除，编辑这个值的属性
例如：
let a = 1;
a.name = 'hello';
这样的话，不会报错，但是也不会生效
同时，我们将一个原始值复制给另外一个变量，那么，另外一个变量得到的是当前复制值的副本，而非原始值本身，在复制过程中，程序会分配一个新的内存空间，放置这个副本值，然后交给另外一个变量
所以，原始值复制后，两个变量虽然值相同，但却是两份数据，二者互不影响
let a = 1;
let b = a;
a = 2;
console.log(a, b);// 2, 1

引用值按引用访问：
引用值在访问是，访问是内存空间中保存的引用/指针，因为Javascript禁止直接访问、操作对象本身
首先，引用值在赋值的过程中，不仅保存了对象的引用，还可以动态保存、操作对象的属性
例如：
let obj = new Object();
obj.name = 'hello';
obj.age = 18;
console.log(obj); {name: "hello", age: 18}
但是在复制过程中，引用对象和原始变量是有区别的，由于对象保存在变量中的是对象的引用，所以，复制给另外一个变量的也是该对象的引用，而不是对象的副本
这就导致了，两个变量都是相同的引用，指向了相同的对象，那么，修改其中任意一个对象的属性内容，都会影响另一个变量
let obj = new Object();
obj.name = 'hello';
let obj2 = obj;
obj.name = 'world';
console.log(obj, obj2); // {name: "world", age: 18}, {name: "world", age: 18}

需要注意的是：
如果，我们通过new 关键字创建一个原始值，那么这个原始值实际上是一个引用类型，也就是对象哦
let str = new String('hello');
console.log(typeof str); // object
2）说明 JavaScript 执行上下文与作用域链的概念及其作用。
执行上下文：
概念：通俗的来讲，执行上下文就是代码执行流当前所处的环境，例如，当代码在全局下执行，那么，全局上下文就是当前的执行上下文，当代码执行流处于一个
函数中，那么函数上下文，就是当前的执行上下文，当代码执行流处于一个块级作用域中，那么块级上下文，就是当前的执行上下文。
简而言之，上下文，就是当前代码或者变量可访问的区域
作用：执行上下文决定了当前执行的代码，可以访问哪些变量
作用域链：
概念：当代码在执行的过程中，Javascript本身会将当前上下文抽象成一个活动对象，这个活动对象会根据区域的不同而有所区别
比如：
全局作用域的活动对象，只会包含window下的全局变量以及函数等
函数作用域的活动对象，会包含arguments对象，以及内部包含的对象与函数
块级作用域的活动对象，会包含块级作用域中声明的变量与函数
然后，这些活动对象，会根据层级，形成一个链式结构，这也就是作用域链
作用：当我们有了作用域链后，一是可以让执行代码流有序的查找代码引用的变量，二是形成隔离，防止作用域不同的变量产生的变量污染，例如本来我是调用一个函数里的a变量，但是全局也有一个a变量，那么通过作用域链，我们也能够尽快的找到我们需要的函数a变量，其次，就是可以优化我们的执行速度，方便我们的变量查找效率

3）阐述 `var`、`let`、`const` 在作用域与提升行为上的差异。
var在全局作用域中，会产生变量声明提升，同时声明的变量会被自动绑定在window对象上，然后我们可以在全局任意一处位置进行访问，甚至在变量声明之前进行访问。
并且let 与 const 则不会产生变量声明提升，同时会产生暂时性死区，在变量声明之前访问变量会导致程序报错。
还有一点，当在函数作用域中声明变量时，变量声明会被提升，但是变量赋值不会被提升
然后var可以重复声明变量，变量会更新值为最后一次赋值的结果，而let和const则不能重复声明变量，变量会报错
在for循环这种块级作用域，使用var声明变量，计算的结果会出现异常，并且可能导致内存泄露，而let与const则不会
var与let赋值后，值可以随意更改，const则不行，const是不能进行随意更改的

4）解释标记-清除与引用计数两种垃圾回收策略的核心思路及主要差异。
标记-清除：
垃圾回收程序执行的时候，会先将内存中存储的所有变量，都标记起来，然后，它会将
所有在上下文中的变量，以及被上下文中的变量引用的变量标记去除掉，那么之后再被加上标记的变量就是待删除的了，原因是任何上下文中的变量都访问不到它们了，随后
垃圾回收程序会做一次内存清理，销毁代表几的所有值并且回收它们的内存
引用计数：
引用计数就是将每一个值，都记录它们被引用的次数，无论是赋值还是变量引用等方式，只要涉及到任意变量，该变量的引用数都会+1，如果是覆盖某一个变量，该变量的引用数就会-1.直到变量的引用数为0，就说明无法访问到这个值了，然后这个值就会被回收掉
5）说明“暂时性死区”（TDZ）是什么，它如何影响变量访问。
概念：Javascript引擎在let声明变量之前，禁止以任务方式来引用未声明的变量
如果在let声明变量之前访问变量，都会抛出ReferenceError

## 五、论述题（5题，解释原理）
1）论述函数调用栈与作用域链如何协同完成标识符解析，并分析访问局部变量与全局变量的性能差异原因。
2）从内存模型角度，论述原始值与引用值的存储与复制原理以及对代码行为的影响。
3）分析 V8 隐藏类的工作原理，讨论动态添加/删除属性对性能的影响以及规避策略。
4）结合浏览器的内存限制，论述为什么应及时解除全局对象引用，并给出实践指南。
5）比较块级作用域与函数作用域在垃圾回收时机上的差别，说明为何 `let/const` 可能更早被回收。

## 六、高频面试题（5题）
1）`typeof null` 为什么是 `"object"`，如何区分对象与 `null`？
为什么：
Javascript在初期发展阶段，所有的值都被存储为32位的单元，每一个单元都包含了两部分
第一部分是【类型标签】，第二部分是【值】
而object的类型标签为000表示，null被表示为机器码中的null指针（全是0），在底层实现中，null的类型标签和对象是一样的
所以，null被typeof检测会返回object
区分null和object
1。 null === value; 通过严格等于符号来进行判断

2）解释 JavaScript 函数参数是否按引用传递，并用代码证明你的结论。
3）什么是暂时性死区，举一个会抛出 ReferenceError 的示例。
4）请说明标记-清除算法的可达性判断如何与作用域链关联。
5）谈谈在浏览器中减少内存泄漏的几条最佳实践。

## 七、高频场景题（5题）
1）一个定时器回调里引用了体积较大的缓存对象且长期不清理，描述问题与解决方案。
2）在 `try...catch` 中声明的错误对象 `err` 何时可被回收？
3）在循环中使用 `var` 声明迭代变量导致闭包捕获同一个变量，如何用块级作用域修正？
4）如何安全地在函数内部区分传入的是原始值还是对象，并据此决定是否深拷贝？
5）页面存在大量短生命周期对象被频繁创建和丢弃，可能触发频繁 GC，给出优化思路。

## 八、场景编程题（5题）
1）实现一个 `isReference(value)` 函数，返回布尔值指示参数是否为引用类型（非原始值）。
2）写一个函数 `safeGetColor()`，在不同作用域下有 `color` 的情况下，优先返回最近作用域的值，若未定义返回 `'unknown'`。
3）编写示例代码演示 `with` 语句如何临时修改作用域链，并指出其风险。
4）实现一个辅助函数 `dispose(obj, keys)`，将对象 `obj` 上的指定属性置为 `null`，用于解除引用，要求不破坏隐藏类（不要使用 `delete`）。
5）写一段代码演示引用计数策略在循环引用下的泄漏问题（伪代码即可），并说明在标记-清除下为何不会泄漏。

## 九、项目开发题（3题）
1）为单页应用设计一份“内存健康检查清单”，涵盖全局变量管理、定时器/事件监听清理、数据缓存生命周期、DOM 引用释放等，要求条目化且可执行。
2）设计一个简单的对象池接口（例如 `allocate` / `free`），并给出在矢量计算场景中使用对象池减少 GC 压力的代码片段与说明。
3）围绕“作用域链与可达性”设计一段教程式示例代码，展示标识符查找顺序、变量屏蔽、以及与垃圾回收可达性判定的关系，并配文字讲解。
