# 第 7 章 迭代器与生成器——学习课件

## 1. 核心知识架构与学习方法
| 模块 | 必备概念 | 对应书中段落/建议 | 学习方法 |
| --- | --- | --- | --- |
| 7.1 理解迭代 | "迭代"定义、循环与有序集合、`for` 与 `forEach` 的局限 | P1-5（迭代引子） | 先用熟悉的数组例子复述，写下“传统循环需要知道索引”这一痛点；在脑图里画出“结构 vs 遍历逻辑”分离。 |
| 7.2.1 可迭代协议 | `Iterable`、`Symbol.iterator`、可迭代对象列表、原生消费者（`for-of`、展开、`Promise.all` 等） | P6-15 | 把书中每个内置类型的 `Symbol.iterator` 输出在控制台里跑一遍 → 建立肌肉记忆；记死：默认迭代器 = 工厂函数。 |
| 7.2.2 迭代器协议 | `Iterator`、`next()`、`IteratorResult {value, done}`、耗尽状态 | P16-23 | 手写最小迭代器（对象 + 闭包），逐步打印 `next()` 结果并截图；强行背下来 `value/done` 的含义与关系。 |
| 7.2.3 自定义迭代器 | 类/闭包实现、一次性迭代 vs 多次迭代、迭代器的可迭代性 | P24-34 | 编写 `Counter` 两个版本（实例自身迭代 vs 工厂模式），比较“第二次遍历失效”的体验；写总结笔记解释原因。 |
| 7.2.4 提前终止 | `return()` 可选、`break/throw` 调用时机、不可关闭迭代器行为 | P35-45 | 用日志 `console.log('Exiting early')` 验证 `break`、`throw`、解构；记忆口诀：“结构停 = return() 调一次；不可关闭 = return 也只能提示”。 |
| 7.3 生成器基础 | `function*`、`yield`、暂停/恢复、生成器对象与迭代器等价 | P46-67 | 跑空生成器、`return` 值和 `yield` 区别；画状态机（suspended → executing → closed）。 |
| 7.3.2 `yield` 输入/输出 | `yield` 既产出又接收、`next(value)` 规则（第一次参数被丢） | P68-85 | 设计“问答”生成器，把日志记录成表格；刻意在第一次 `next()` 传值体验“为什么没用”。 |
| 7.3.2 `yield*` | 迭代委托、返回值传递、递归场景 | P86-105 | 写 `range/zeroes` 与 `yield*` 版；画出“主迭代器←子迭代器”箭头理解值回传。 |
| 7.3.3 默认迭代器 | 生成器作为 `[Symbol.iterator]`、与类成员结合 | P106-112 | 给自己的类写一个 `*[Symbol.iterator]()`；在 `for-of/spread` 中使用。 |
| 7.3.4 关闭生成器 | `return()`、`throw()`、`try/catch` 中断后跳过值 | P113-125 | 用 `console.log` 观察 `throw` 跳过一次 `yield`；记录“未启动时 throw = 在外面抛”这条规则。 |

> **需要铭记的最小骨架**：`Iterable` 暴露 `Symbol.iterator` → 工厂返回 `Iterator` → `Iterator.next()` 返回 `{value, done}` → `for...of`/`yield*` 等结构重复调用；生成器是写迭代器的语法糖 + 协程能力。

## 2. 为什么要掌握迭代器与生成器
1. **抽象遍历方式**：告别“遍历=知道索引”，任何数据结构都能统一被消费，增强可组合性。
2. **惰性和无限序列**：按需生产数据（分页、流式读取、实时数据）。
3. **可中断/协程思维**：`yield` 带来的暂停/恢复是实现轻量协程、框架内部控制流（Redux Saga、Koa）的大前提。
4. **生态兼容性**：ES 规范中大量 API（`Promise.all`、`for await...of`）都依赖迭代协议，面试与实际开发都是硬指标。
5. **代码可读性/可测性**：把状态机逻辑拆成生成器片段，单步调试更容易。

## 3. 它们解决的核心问题与实际场景
| 问题 | 解决方式 | 商业级示例 |
| --- | --- | --- |
| 遍历逻辑与数据结构耦合（必须知道索引/内部结构） | `Symbol.iterator` 抽象出“如何取下一个值” | UI 组件库设计 `Tree`, `List`，任何内部实现都可被 `for-of` 渲染；GraphQL resolver 遍历字段结果。 |
| 大数据/无限数据无法一次性加载 | 迭代器/生成器懒产出，配合 `for...of`/`for await...of` | SaaS 报表系统逐页查询数据库，每页处理后继续请求，避免内存爆炸。 |
| 协程式业务流程需要暂停/等待外部事件 | 生成器 `yield` + 调度器 | Redux-Saga 中 `yield call(api)` 暂停等待；游戏脚本按帧执行 `yield` 控制节奏。 |
| 复杂递归/图遍历可读性差 | `yield*` 递归委托，让 DFS/BFS 更直观 | 推荐系统需要遍历图结构寻找相似节点，使用递归生成器 + `yield*` 实现深度优先搜索。 |
| 需要统一处理“中止/清理” | 迭代器 `return()`、生成器 `throw()` | 文件读取中断后自动关闭句柄；Node.js Stream 在错误发生时触发清理逻辑。 |

## 4. 练习题
### 4.1 理论题
1. 解释 `Iterable` 与 `Iterator` 的区别与联系，并举一个只实现其一的例子说明。
2. 为什么 `Array.prototype.forEach` 不能满足通用迭代需求？列举两点理由。
3. `yield*` 返回值来自哪里？描述它在三个不同场景（普通数组、generator、有 `return` 值的 generator）下的差异。
4. 描述 `g.throw()` 在生成器未启动、运行中有 try/catch、运行中无 try/catch 三种状态下的表现。

### 4.2 编程题
1. **惰性分页器**：实现 `function createPaginator(fetchPage)`，返回一个可迭代对象。每次迭代调用 `fetchPage(pageIndex)`（返回 Promise），仅在上一页完成后继续下一页，直到返回空数组为止。
2. **温度传感器流**：写一个生成器 `function* sensorStream(read)`，每次 `yield read()`，但当读数为 `null` 时通过 `return()` 终止并输出“最后一次有效读数”。要求写测试展示 `return()` 被 `break` 触发。
3. **图遍历**：给定节点对象 `{ value, neighbors: Node[] }`，用 `yield*` 编写 `function* dfs(node, visited = new Set())`，确保不会重复访问。

### 4.3 场景题
1. 你负责的电商后台订单列表需要支持“无限下滑加载”。请描述如何用迭代器/生成器组织请求逻辑，并说明它对内存和用户体验的影响。
2. 一个 Node.js CLI 工具有“逐文件处理”功能，但客户要求可在处理中途安全取消。如何利用迭代器的 `return()` 或生成器的 `throw()` 提前终止并做清理？
3. 在微前端架构里，多团队输出不同的组件集合。你要统一封装一个 `ComponentRegistry` 使其可被 `for...of` 消费并支持动态增删。设计其迭代协议。

## 5. 学习策略与补充建议
1. **分层吸收**：先掌握“协议”后学“语法糖”（生成器）。每学完一节写一句“我能用它干嘛”的总结。
2. **动手验证**：每个概念最少写一个 `console.log` Demo，跑在浏览器或 Node REPL，截图保存到“读书笔记”。
3. **追踪情绪**：学习日志记录“今天卡在 yield*，感受是 ___，我用 ___ 验证后搞懂了”。把挫败感转化为行动计划。
4. **交叉应用**：尝试把当前项目里的“逐步处理”逻辑改成生成器风格；即便最终不用，也能验证理解深度。
5. **延伸阅读**：
   - MDN：Iterator Protocol / Generator
   - 《You Don’t Know JS Yet: Sync & Async》关于协程的章节
   - Redux-Saga、Koa 中的生成器实践源码
6. **自测闭环**：
   - 24h 复述核心概念 → 72h 内用一次生成器解决真实任务。
   - 与同事/朋友讲“yield* 如何做递归”，若能顺畅说明即掌握。
7. **面试导向笔记**：整理两个“迭代器改造业务”的案例，方便面试或分享。

> **最终目标**：看到任何“需要顺序产出值”的需求，第一反应能想到“我可以暴露一个迭代器/写一个生成器”，并根据需要控制暂停、恢复、终止与递归。


