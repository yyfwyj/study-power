# 7.1 理解迭代 学习总结 V1
## 1. 什么是迭代？
`迭代，就是有规则的重复执行一段代码，例如：For循环就算作是一个基础的迭代形式`

```
    for (let i = 0; i< 10; i++) {
        console.log(i);
    }
```
如上，就是一个简单的**循环迭代**代码，当然，也不只是如上的应用，循环，最初主要还是针对**数组**来使用的。


至于什么是**集合**呢？什么又是**有序集合**呢？
1. 集合：集合是一个无序的，不重复的序列，集合中的元素是唯一的。
例如:`Set结构`
```
    let set = new Set();
    set.add(1);
    set.add(2);
    set.add(3);
```
这样我们就实现了一个**集合**。

2. 关于数组的迭代，我们一般使用**for循环**来迭代数组。
```
    let arr = [1,2,3,4,5,6,7,8,9,10];
    for (let i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }
```

这就是最为基础的迭代使用方法了，我们可以根据数组的索引，访问到数组的每一个元素再加以使用。

但是，这种迭代方式，始终还是有一定的局限：
* 首先，必须要知道数组的长度。然后使用索引去访问每一个元素，然后我们还需要知道每一个元素的结构，然后才能针对性的使用
* 其次，这种访问并非是因为数组是有顺序的，而是根据索引进行元素的访问，那么如果将两个索引不同的元素位置对调，也不会影响到迭代结果。

这样对于其他的数据结构就并不是很友好，因为其他的数据结构，并非一定会有索引，也不一定有顺序，而且也有可能我们并不知道数据结构中的元素结构。

# 2. ES5 ForEach
ForEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。这算是Javascript初步尝试实现迭代器的一种方式。
```
    const arr = [1, 2, 3, 4, 5];
    arr.forEach( item => console.log(item));
```
不过**ForEach**这个方法，是不能够停止的，官方没有提供关于**停止ForEach**的API。即使是**return**，也只能跳过当前的循环，不能结束整个循环。
例子：
```
    const arr = [1, 2, 3, 4, 5];
    arr.forEach( item => {
        if(item === 3) {
            return;
        }
        console.log(item);
    })

    // 输出：1, 2, 4, 5 （3 被跳过，但循环没停！）
```

# 7.1 理解迭代 学习总结 V2
当我们需要了解什么是迭代器和生成器的时候，我们需要先了解一个概念——**迭代**

最为标准和基础的代表，就是使用``for循环``实现一个计数循环

这个循环，它就实现了迭代一些明显特征：
1. 明确指定了迭代次数
2. 每一个元素的结构很明确
3. 可以明确指出迭代的开始和结束，并且能够控制迭代的开始和结束

同时，迭代的内部逻辑代码，通常是固定不变的，那么就代表了，它对于数据的顺序和稳定是有一定要求的，所以**迭代**更多的是指向**有序集合**来使用。

但是，循环的话，也有一定的限制，它要求我们：
1. 必须知道循环元素的结构
2. 如果是数组一类，我们就很依赖数组索引来访问元素

但是这样就对其他的元素集合不太友好，比如对象集合，没有索引，同时我们不一定知道元素结构，并且，无法准确的去控制迭代的开始和结束，还有，迭代内部的逻辑代码，就很难去固定

所以，在ES5的时候，Javascript引入了一个新的API：forEach

forEach，可以无需通过元素索引就可以进行迭代，但是它的问题也很明显：
1. 无法控制迭代的结束
2. 除了数组，其他的对象结构几乎不能得到支持，比如对象，字符串
3. 回调笨拙我个人感觉还行，还可以接受，但是确实没那么方便
```
    let arr = [1,2,3,4,5];
    arr.forEach((item) => {
        console.log(item);
    })
```

并且，无论是使用for循环，还是forEach，都需要我们对内部的元素结构比较了解才能更好的使用（这一点，我不太理解，比如说数组里的子元素都是对象，我可以先遍历输出进行了解呀，只是麻烦了一点）



