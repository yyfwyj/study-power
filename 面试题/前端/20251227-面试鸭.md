1. 什么是 Vue 中的 slot？它有什么作用？
   首先，slot 机制是 Vue 用于增强组件的复用性、通用性、灵活性的一种机制。
   它可以让组件内部接收外部的内容，然后渲染到组件内容。
   常用于嵌套组件的场景，比如：表单，输入框，列表等等
   slot 有多个插槽概念：
   · 匿名插槽：就是默认插槽，主要针对一个插槽的时候使用，外部内容传入进来，直接渲染到插槽内部
   · 具名插槽：针对多个插槽，且对渲染内容有位置的要求和条件的时候使用，当我们给插槽使用 name
   属性的时候，就实现具名插槽了，外部需要传入内容到指定插槽的时候，那我们则在<template>标签上使用:name="name"来指定插槽名，或者是以#号作为缩写：#name="name"
   · 作用域插槽: 当我们希望父组件能直接通过插槽访问到子组件的属性的时候，就会使用到作用于插槽，使用方式是：子插槽中通过 :键名="变量名"的方式传入数据，父组件在使用组件的时候，通过
   <template #name="{ 变量名 }">的形式进行渲染，内部数据使用变量就是【变量名.属性名】的方式
   · 动态插槽：我们可以制定一个判断条件，当条件为 true/false 的时候，得到不同的插槽名称，然后将内部渲染到不同的插槽内部
   例如：<template #[slotName]></template>
   · 条件插槽：条件插槽，就是指当插槽有数据的时候就渲染，没数据的时候就不渲染，而使用方法就是在组件定义插槽的时候，通过 V-if 配合$slots的方式来实现，例如：
<template v-if="$slots.header"></template>

2. 如果要实现一个 Vue3 的弹窗组件，你会如何设计?
   查看相关文件，理解实现原理并整理面试回答：

[5 tools called]

下面解释原理，并给出面试回答建议。

## 一、Vue3 命令式弹窗的核心原理

### 1. 核心概念：动态组件实例化

命令式弹窗的核心是**动态创建和销毁 Vue 组件实例**，而不是在模板中声明。

### 2. 实现流程（逐步解析）

#### 步骤 1：创建 DOM 容器

```javascript
const container = document.createElement("div");
document.body.appendChild(container);
```

- 创建一个 `<div>` 作为挂载点
- 直接添加到 `body`，避免层级问题

#### 步骤 2：创建独立的 Vue 应用实例

```javascript
const app = createApp({
  setup() {
    const visible = ref(true);
    // ... 其他逻辑
  },
});
```

- `createApp` 创建一个独立的 Vue 应用
- 与主应用隔离，有自己的响应式系统

#### 步骤 3：使用渲染函数动态创建组件

```javascript
return () =>
  h(
    Modal,
    {
      visible: visible.value,
      title: options.title,
      // ... props
    },
    {
      default: () => options.content,
    }
  );
```

- `h` 函数（createElement）创建虚拟 DOM
- 动态传入 props 和插槽内容
- 返回一个渲染函数

#### 步骤 4：挂载到容器

```javascript
app.mount(container);
```

- 将应用挂载到容器
- Vue 开始渲染组件到 DOM

#### 步骤 5：销毁和清理

```javascript
visible.value = false;
setTimeout(() => {
  app.unmount(); // 卸载应用实例
  document.body.removeChild(container); // 移除DOM
}, 300); // 等待动画完成
```

- 先隐藏（触发离开动画）
- 延迟销毁，等待动画完成
- 卸载应用并移除 DOM，避免内存泄漏

### 3. 关键技术点

| 技术点          | 作用             | 为什么重要                       |
| --------------- | ---------------- | -------------------------------- |
| `createApp`     | 创建独立应用实例 | 与主应用隔离，可独立管理生命周期 |
| `h` 函数        | 创建虚拟 DOM     | 动态创建组件，灵活传参           |
| `Teleport`      | 传送到 body      | 避免 z-index 和定位问题          |
| `Transition`    | 过渡动画         | 提供流畅的显示/隐藏效果          |
| `ref` + `watch` | 响应式状态管理   | 控制弹窗显示/隐藏                |

### 4. 与声明式方式的对比

**声明式方式（传统）：**

```vue
<template>
  <Modal v-if="showModal" :title="title" @close="showModal = false" />
</template>
```

- 需要在模板中写组件
- 需要维护状态变量
- 受限于组件树结构

**命令式方式（函数调用）：**

```javascript
showModal({ title: "提示", content: "内容" });
```

- 无需模板代码
- 一行代码调用
- 可在任何地方使用（工具函数、API 回调等）

---

## 二、面试回答框架

### 回答结构：设计思路 → 技术实现 → 优化考虑

---

### 回答示例

> **面试官：如果要实现一个 Vue3 的弹窗组件，你会如何设计？**

**我的回答：**

我会从**组件设计**和**使用方式**两个维度来设计：

#### 一、组件设计层面

**1. 基础结构设计**

- 使用 `Teleport` 将弹窗传送到 `body`，避免 z-index 和定位问题
- 使用 `Transition` 实现进入/离开动画
- 采用遮罩层 + 内容容器的双层结构

**2. Props 设计**

```javascript
{
  visible: Boolean,        // 控制显示/隐藏
  title: String,           // 标题
  showFooter: Boolean,     // 是否显示底部按钮
  closeOnClickOverlay: Boolean,  // 点击遮罩是否关闭
  closeOnPressEscape: Boolean    // 按ESC是否关闭
}
```

**3. 事件设计**

- `update:visible` - 支持 v-model
- `close` - 关闭事件
- `confirm` - 确认事件
- `cancel` - 取消事件

**4. 交互体验**

- 打开时禁止背景滚动（`body.style.overflow = 'hidden'`）
- 支持 ESC 键关闭
- 点击遮罩层关闭（可配置）
- 动画过渡效果

#### 二、使用方式设计

我会提供**两种使用方式**：

**方式 1：声明式（传统方式）**

```vue
<Modal v-model:visible="show" title="提示">
  <p>内容</p>
</Modal>
```

适合固定位置的弹窗。

**方式 2：命令式（函数调用）**

```javascript
showModal({ title: "提示", content: "内容" });
```

适合动态、临时弹窗，如 API 错误提示、确认对话框等。

#### 三、命令式实现原理

命令式实现的核心是**动态创建 Vue 应用实例**：

```javascript
function createModal(options) {
  // 1. 创建容器
  const container = document.createElement("div");
  document.body.appendChild(container);

  // 2. 创建独立应用实例
  const app = createApp({
    setup() {
      const visible = ref(true);

      const close = () => {
        visible.value = false;
        setTimeout(() => {
          app.unmount(); // 卸载应用
          document.body.removeChild(container); // 移除DOM
        }, 300); // 等待动画完成
      };

      // 3. 使用渲染函数动态创建组件
      return () =>
        h(
          Modal,
          {
            visible: visible.value,
            title: options.title,
            "onUpdate:visible": (val) => {
              visible.value = val;
              if (!val) close();
            },
            onClose: close,
            onConfirm: () => {
              options.onConfirm?.();
              close();
            },
          },
          {
            default: () => options.content,
          }
        );
    },
  });

  // 4. 挂载到容器
  app.mount(container);

  return { close };
}
```

**关键技术点：**

- `createApp` 创建独立应用实例
- `h` 函数动态创建组件
- 手动管理生命周期（创建、挂载、销毁）
- 延迟销毁等待动画完成

#### 四、扩展功能

**1. 便捷方法**

- `showModal()` - 通用弹窗
- `showConfirm()` - 确认对话框
- `showAlert()` - 提示信息
- `showPrompt()` - 输入对话框

**2. 可扩展方向**

- 支持 Promise（async/await）
- 支持自定义动画
- 支持不同尺寸和位置
- 支持主题定制
- 支持国际化

#### 五、注意事项

1. 内存管理：确保关闭时正确卸载应用实例
2. 事件清理：移除事件监听器，避免内存泄漏
3. 动画处理：等待动画完成后再销毁 DOM
4. 多实例：支持同时打开多个弹窗
5. 样式隔离：使用 scoped 避免样式冲突

---

### 面试加分点

1. 对比两种使用方式，说明适用场景
2. 解释命令式实现的核心原理（动态实例化）
3. 提到性能优化（延迟销毁、事件清理）
4. 说明可扩展性（Promise、主题、国际化）
5. 强调用户体验（动画、键盘支持、背景滚动控制）

### 如果面试官深入提问

**Q: 为什么要用 `createApp` 而不是直接渲染组件？**  
A: `createApp` 创建独立应用实例，与主应用隔离，可以独立管理生命周期，避免影响主应用状态。

**Q: 为什么要延迟销毁？**  
A: 等待 `Transition` 动画完成（通常 300ms），确保用户看到完整的关闭动画，提升体验。

**Q: 如何支持 Promise？**  
A: 在 `createModal` 中返回 Promise，resolve/reject 在用户点击确认/取消时调用。

---

这个回答框架涵盖了设计思路、技术实现和优化考虑，能体现对 Vue3 和组件设计的理解。 
3. Vue 的 v-cloak 和 v-pre 指令有什么作用?
v-cloak：用于解决 Vue 模板编译过程中，元素出现闪烁的问题，就比如一个标签内通过一个变量渲染数据，那么有可能他会产生【{{变量名}}】的文本，而不是我们需要的数据
那么就可以使用 v-cloak，然后通过 css 的属性选择器选择这个携带了 v-cloak 的元素，再通过 display:none 来隐藏这个元素。再等元素渲染完毕以后，VUE 会自动地移除这个属性，让元素正常显示出来
但是，这个问题只有在 HTML 单独引入 Vue.js 库的时候才会出现，我们常规开发中，都是使用 Vite 或者 webpack 这种工程化工具构建项目，vue 会自动地移除这个属性，所以这个问题不会出现
v-pre：用于告诉 Vue，这个元素及其子元素的内容不会被编译，而是直接渲染为普通 HTML 4. 你了解 Vue 中的过滤器吗?它有哪些应用场景?
过滤器，就是指将数据二次加工的一种方式，通过管道符号（|）来将数据传递到对应过滤器当中，然后过滤器可以将指定数据格式化为我们想要展示的文本或者是不同的 CSS 样式。这种方式常用语 Vue2 当中。
主要针对的是例如一些状态，时间，金额等数据
但是在 Vue3 中，过滤器 filters 已经被废弃了，官方更加倾向于通过计算属性或者是自定义函数来处理数据格式 
5. 如何在页面内一次性渲染 10 万条数据，并保证页面不卡顿?
1. 长任务分片
2. requestAnimationFrame
3. 文档碎片 document.createDocumentFragment
4. 虚拟列表
